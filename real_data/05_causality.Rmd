---
title: "Causality analysis"
output:
  html_document:
    toc: true
    theme: united
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
---

```{r}
# load packages
library(ggplot2)   
#install.packages("mpmi")
library(mpmi)

# For PC analysis
library(reticulate)
library(tidyverse)
library(ggpubr)
library(dagitty)
library(broom)
library(pheatmap)
# load data

library(survival)
library(survminer)
library(gridExtra)

# for theoretical exploration
AMR_matrix = readRDS("~/projects/tims-pdac/real_data/results/04_tcga_imm_AMR_matrix_fdr0_05_V2_K8_corrected.rds")
tcga_data = readRDS("~/projects/tims-pdac/real_data/tcga_pdac_mediation/results/01_tcga_data_expo_deconv.rds")


#get the results of serial mediation
idx_woLF = readRDS("~/projects/tims-pdac/real_data/results/06_TCGA_serial_med_top50_V2_K8_corrected_without_LF_selected_combinaison.rds") # without Latent Factor
length(idx_woLF)
idx_wLF = readRDS("~/projects/tims-pdac/real_data/results/06_TCGA_serial_med_top50_V2_K8_corrected_with_LF_selected_combinaison.rds") # with Latent Factor
length(idx_wLF)

# for independance testing
#datAMR = read.csv2("results/tcga_AMR_mean_meth_top50.csv", header = TRUE, stringsAsFactors = FALSE, row.names = 1, sep = ",")
datAMR = read.csv2("~/projects/tims-pdac/real_data/results/03_tcga_AMR_mean_meth_top50_fdr0_05_V2_K8_corrected.csv", header = TRUE, stringsAsFactors = FALSE, row.names = 1, sep = ",") #to check

#significant AMR
tobacco_AMR <- readRDS("~/projects/tims-pdac/real_data/results/03_tcga_significative_from_top50_tobacco_AMR_fdr0_05_V2_K8_corrected.rds")

datIMM = read.csv2("~/projects/tims-pdac/real_data/results/03_tcga_consensus_deconv_immune_cells.csv", header = TRUE, stringsAsFactors = FALSE, row.names = 1, sep = ",")
datIMM[] <- lapply(datIMM, function(x) as.numeric(as.character(x)))
datIMM$all = rowSums(datIMM)

#result of the mediation to collect latent factors

res_med = readRDS("~/projects/tims-pdac/real_data/results/02_tcga_med_tobacco_dnam_V2_K8_corrected.rds")
LFs = res_med$hdmax2_step1_param$AS_1$U
colnames(LFs) = paste0("LF_", c("A", "B", "C", "D", "E", "F", "G", "H"))
```

# Theoretical exploration on linear non-Gaussian causal models

## Reproduction of Hoyer et al, 2008 (uniform distribution)



This code is a reproduction of the theoretical exploration of Hoyer et al, 2008 (Figure 1 cases II and III). 
It is not used in the main analysis of the paper, but it is useful to understand the theoretical background of the causal inference methods used in the paper.


Source : 

Patrik O. Hoyer, Shohei Shimizu, Antti J. Kerminen, Markus Palviainen,
Estimation of causal effects using linear non-Gaussian causal models with hidden variables,
International Journal of Approximate Reasoning,
Volume 49, Issue 2, 2008,Pages 362-378, ISSN 0888-613X,
[link](https://doi.org/10.1016/j.ijar.2008.02.006)



```{r}
alpha = 1

e1 = runif(1000)
e2 = runif(1000)

#first model x1 -> x2
x1 = e1
x2 = alpha*x1 + e2

#second model x3 <- x4
x4 = e2
x3 = alpha*x4 + e1

layout(matrix(1:2, nrow = 1))
plot(x1,x2)
plot(x3,x4)
```

## With errors following a beta distrubtion

We assume that AMR and immune proportion are following a beta distribution. 

```{r}
alpha = 1

e1 = rbeta(1000, 0.5, 0.5)
e2 = rbeta(1000, 0.5, 0.5)

#first model x1 -> x2
x1 = e1
x2 = alpha*x1 + e2

#second model x3 <- x4
x4 = e2
x3 = alpha*x4 + e1

layout(matrix(1:2, nrow = 1))
plot(x1,x2)
plot(x3,x4)
```

## A basic test to estimate directionality

```{r load}
#first model x1 -> x2
var1 = x1
var2 = x2
mod_forward = lm(var2 ~ var1)
res_forward = mod_forward$residuals
mod_backward = lm(var1 ~ var2)
res_backward = mod_backward$residuals

layout(matrix(1:6, nrow = 2))
    plot(var1, res_forward, main = "Forward model = TRUE")
    plot(var2,res_backward, main = "Backward model = FALSE")
    plot(var1, e1, main = "Ground truth var 1")
    plot(var1, e2, main = "Ground truth var 1")
    plot(var2, e1, main = "Ground truth var 2")
    plot(var2, e2, main = "Ground truth var 2")
    
#second model x1 <- x2
var1 = x3
var2 = x4
mod_forward = lm(var2 ~ var1)
res_forward = mod_forward$residuals
mod_backward = lm(var1 ~ var2)
res_backward = mod_backward$residuals

layout(matrix(1:6, nrow = 2))
    plot(var1, res_forward, main = "Forward model = FALSE")
    plot(var2,res_backward, main = "Backward model = TRUE")
    plot(var1, e1, main = "Ground truth var 1")
    plot(var1, e2, main = "Ground truth var 1")
    plot(var2, e1, main = "Ground truth var 2")
    plot(var2, e2, main = "Ground truth var 2")
```

## A generic function with mutual information

```{r}

function_causality = function(x1, x2){
  # model 1
  mod_forward = lm(x2 ~ x1)
  res_forward = mod_forward$residuals
   mi_cont <- mpmi::cmi(cbind(x1,res_forward)) # mutual information on continuous variables
    zscore_fw = lapply(mi_cont, round, 2)$zvalues[1,2] #Z-scores for each hypothesis that the corresponding BCMI value is zero. These have poor statistical properties but can be useful as a rough measure of the strength of association.
  #model 2
      mod_backward = lm(x1 ~ x2)
  res_backward = mod_backward$residuals
  mi_cont <- mpmi::cmi(cbind(x2,res_backward)) # mutual information on continuous variables
    zscore_bw = lapply(mi_cont, round, 2)$zvalues[1,2] #Z-scores for each hypothesis that the corresponding BCMI value is zero. These have poor statistical properties but can be useful as a rough measure of the strength of association.
  return(list(x1 = x1, x2 = x2, forward = res_forward, backward = res_backward, zscore_fw = zscore_fw, zscore_bw = zscore_bw))
}

```

## Application on real data 

```{r}
#sign corr
imm_tot = tcga_data$prop_immune

plot(density(imm_tot))

cor_matrix = apply(AMR_matrix$mean_meth_AMR, 2, FUN = function(AMR) { 
                   cor =cor.test(AMR,imm_tot)$estimate
                   pval = cor.test(AMR,imm_tot)$p.value
                   return(list(cor = cor, pvalue = pval))
                     })

cor_matrix = do.call(rbind,cor_matrix)
cor_matrix = data.frame(lapply(data.frame(cor_matrix, stringsAsFactors=FALSE), unlist), stringsAsFactors=FALSE)
rownames(cor_matrix) = colnames(AMR_matrix$mean_meth_AMR)
#AMR_subset = rownames(cor_matrix[which(cor_matrix$pvalue < 0.01),])         
AMR_subset = rownames(cor_matrix) # pour prendre toutes les AMRs
length(AMR_subset)
AMR_subset

res_causality = apply(AMR_matrix$mean_meth_AMR[,AMR_subset],2, function(x) {
  function_causality(x,imm_tot)
  })

for (AMR_name in AMR_subset){
  cur = res_causality[[AMR_name]]
  plot_MI(cur, title = AMR_name)

}

#save results
saveRDS(res_causality, "~/projects/tims-pdac/real_data/results/05_tcga_causality.rds")
```
 

## Conclusion

On real data, the results are not conclusive. The mutual information does not provide enough information to decipher the graph orientation. Hypothesis : the relationship between AMR and immune proportions is not linear, or the noise is too high to detect the causal relationship.


# Analysis for the paper

## Run causal discovery with LF

### Correlation

```{r}

# Compute Pearson correlation matrix between LFs and datIMM
cor_matrix_LF <- cor(LFs, datIMM, use = "pairwise.complete.obs", method = "pearson")

# Function to get p-value from Pearson correlation test between two vectors
get_pval <- function(x, y) cor.test(x, y, use = "pairwise.complete.obs", method = "pearson")$p.value

# Vectorized computation of p-values for all combinations of columns in LFs and datIMM
pval_matrix_LF <- outer(
  1:ncol(LFs), 1:ncol(datIMM),
  Vectorize(function(i, j) get_pval(LFs[, i], datIMM[, j]))
)

# Set row and column names of the p-value matrix to match LFs and datIMM column names
dimnames(pval_matrix_LF) <- list(colnames(LFs), colnames(datIMM))

# Bonferroni adjusted significance threshold
alpha_adj <- 0.01 / (50+ 6) # 50 LFs + 6 immune variables

# Convert correlation matrix to a data frame for ggplot
df_plot <- as.data.frame(as.table(cor_matrix_LF))
colnames(df_plot) <- c("LF", "Immune", "Correlation")

# Add corresponding p-values to the data frame
df_plot$p.value <- mapply(function(lf, im) pval_matrix_LF[lf, im], df_plot$LF, df_plot$Immune)

# Mark correlations as strong if absolute correlation is greater than 0.4
df_plot$Strong <- abs(df_plot$Correlation) > 0.4

df_plot$significance <- ifelse(df_plot$p.value <= alpha_adj, "Significant", "Not Significant")

# Create dot plot with correlation magnitude as size, correlation value as color,

p_imm = ggplot(df_plot, aes(x = Immune, y = LF)) +
  geom_point(aes(size = abs(Correlation),
                 color = Correlation,
                 shape = significance),
             stroke = 1.2, fill = "white") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red",
                        midpoint = 0, limits = c(-1, 1), name = "Correlation") +
  scale_size(range = c(0, 5), name = "|Correlation|") +
  scale_shape_manual(values = c("Significant" = 21, "Not Significant" = 17)) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Correlations between LFs and immune variables",
       shape = "pval < 0.01",
       x = "Immune",
       y = "LF")

# Compute Pearson correlation matrix between LFs and datAMR
cor_matrix_AMR <- cor(LFs, datAMR, use = "pairwise.complete.obs", method = "pearson")

# Function to get p-value from Pearson correlation test between two vectors
get_pval <- function(x, y) cor.test(x, y, use = "pairwise.complete.obs", method = "pearson")$p.value

# Vectorized computation of p-values for all combinations of columns in LFs and datAMR
pval_matrix_AMR <- outer(
  1:ncol(LFs), 1:ncol(datAMR),
  Vectorize(function(i, j) get_pval(LFs[, i], datAMR[, j]))
)

# Set row and column names of the p-value matrix to match LFs and datAMR column names
dimnames(pval_matrix_AMR) <- list(colnames(LFs), colnames(datAMR))

# Bonferroni adjusted significance threshold
alpha_adj <- 0.01 / (50+ 6) # 50 LFs + 6 immune variables

# Convert correlation matrix to a data frame for ggplot
df_plot_AMR <- as.data.frame(as.table(cor_matrix_AMR))
colnames(df_plot_AMR) <- c("LF", "AMR", "Correlation")

# Add corresponding p-values to the data frame
df_plot_AMR$p.value <- mapply(function(lf, amr) pval_matrix_AMR[lf, amr], df_plot_AMR$LF, df_plot_AMR$AMR)

# Mark correlations as strong if absolute correlation is greater than 0.4
df_plot_AMR$Strong <- abs(df_plot_AMR$Correlation) > 0.4

df_plot_AMR$significance <- ifelse(df_plot_AMR$p.value <= alpha_adj, "Significant", "Not Significant")


p_amr = ggplot(df_plot_AMR, aes(x = AMR, y = LF)) +
  geom_point(aes(size = abs(Correlation),
                 color = Correlation,
                 shape = significance),
             stroke = 1.2, fill = "white") +
  scale_color_gradient2(low = "blue", mid = "white", high = "red",
                        midpoint = 0, limits = c(-1, 1), name = "Correlation") +
  scale_size(range = c(0, 5), name = "|Correlation|") +
  scale_shape_manual(values = c("Significant" = 21, "Not Significant" = 17)) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(title = "Correlations between LFs and immune variables",
       shape = "pval < 0.01",
       x = "AMR",
       y = "LF")


combined_plot <- p_imm + p_amr + plot_layout(guides = "collect") & theme(legend.position = "bottom")

# --- Save combined plot as PDF ---

#ggsave("~/projects/thema_surv/real_data/figures/05_combined_correlation_plots.pdf", combined_plot,
#       width = 14, height = 6, units = "in")




#### SELECT COMBINATIONS :

# Vecteurs de noms
immune_vars <- colnames(datIMM)
amr_vars <- colnames(datAMR)
lf_vars <- colnames(LFs)

# Liste pour stocker les résultats
pairs_list <- list()

# Pour chaque combinaison Immune–AMR
for (immune in immune_vars) {
  for (amr in amr_vars) {
    
    # Récupère les corrélations LF vs immune et LF vs amr
    #cor_immune <- cor_matrix_LF[, immune]
    #cor_amr <- cor_matrix_AMR[, amr]
    pval_immune <- pval_matrix_LF[, immune]
    pval_amr <- pval_matrix_AMR[, amr]
    
    # Sélectionne les LFs où les deux corrélations sont > 0.4 en valeur absolue
    #valid_lfs <- lf_vars[abs(cor_immune) > 0.4 & abs(cor_amr) > 0.4]
    valid_lfs <- lf_vars[pval_immune <= alpha_adj & pval_amr <= alpha_adj]
    
    # S'il y a des LFs valides, les stocker
    if (length(valid_lfs) > 0) {
      pairs_list[[paste( amr,immune, sep = "-")]] <- valid_lfs } 
    else {
      pairs_list[[paste( amr,immune, sep = "-")]] <- NA
    } 
  }
}

# Affiche un exemple
pairs_list[1]

saveRDS(pairs_list, file = "~/projects/tims-pdac/real_data/results/05_signLFs_by_pairs-A-I.rds")

```

### Causal discovery

```{r}

# Data processing
AMR_names = colnames(datAMR)
smoking = ifelse(tcga_data$tobacco==0, 'Non-smoker', 'Smoker')
names(smoking) = rownames(tcga_data$M)
labels = smoking[rownames(datAMR)]
smoking_status = as.numeric(as.factor(labels))

pval_thres = 0.1

# details of each model for publication:

prop100= datIMM[,"Tot. Imm."]*100 #to interpret the HR has increase of 1 unit (1% of immune infiltration) lead to HR likely to dire than persons with 1% less
mod = survival::coxph(survival::Surv(tcga_data$time, tcga_data$status) ~ prop100 + tcga_data$age + tcga_data$gender +  tcga_data$grade)
summary(mod)

prop100= datIMM[,"B cells"]*100 #to interpret the HR has increase of 1 unit (1% of immune infiltration) lead to HR likely to dire than persons with 1% less
mod = survival::coxph(survival::Surv(tcga_data$time, tcga_data$status) ~ prop100 + tcga_data$age + tcga_data$gender +  tcga_data$grade)
summary(mod)

prop100= datIMM[,"DCs"]*100 #to interpret the HR has increase of 1 unit (1% of immune infiltration) lead to HR likely to dire than persons with 1% less
mod = survival::coxph(survival::Surv(tcga_data$time, tcga_data$status) ~ prop100 + tcga_data$age + tcga_data$gender +  tcga_data$grade)
summary(mod)

# Latent factor assessment

surv_LF = apply(LFs, 2, function(x) {
   survival::coxph(survival::Surv(tcga_data$time, tcga_data$status) ~ x)
})

surv_LF

cor = apply(LFs, 2, function(x) {
  cor.test(x, smoking_status)$p.value
})

cor


# Step 1: Unconditional independence resting

## Tobacco-Survival association: Cox proportional hazards model

SURV_TOB = survival::coxph(survival::Surv(tcga_data$time, tcga_data$status) ~  smoking_status + tcga_data$age + tcga_data$gender +  tcga_data$grade )
summary(SURV_TOB)

## Tobacco-Immune associations: Linear regression models

IMMtot_TOB = lm(datIMM[ ,"Tot. Imm."]~smoking_status + tcga_data$age + tcga_data$gender +  tcga_data$grade )    
summary(IMMtot_TOB) 

IMMbcell_TOB = lm(datIMM[ ,"B cells"]~smoking_status + tcga_data$age + tcga_data$gender +  tcga_data$grade )    
summary(IMMbcell_TOB) 

IMMDCs_TOB = lm(datIMM[ ,"DCs"]~smoking_status + tcga_data$age + tcga_data$gender +  tcga_data$grade)
summary(IMMDCs_TOB) 


AMR_names = tobacco_AMR$AMR_info$AMR

num_res = list()

for (AMR in AMR_names){ 
  
  for (imm in immune_names) {
   
    
       pair = paste(AMR, "-", imm, sep = "")
 print(paste0("Testing AMR:", AMR, " and Immune:", imm))
 
 # Get significant LFs 
  LFs_names = pairs_list[[pair]]
  covar =   data.frame(age = tcga_data$age,
                         gender = tcga_data$gender,
                         grade =   tcga_data$grade
    )
  if (is.na(LFs_names[1])) {
    print(paste0("No significant LFs for pair: ", pair))
  } else {
    print(paste0("Significant LFs for pair: ", pair, " are: ", paste(LFs_names, collapse = ", ")))
    covar = cbind(covar, LFs[, LFs_names, drop = FALSE])
  }
  

 # Check consisty of T -> AMR -> S path
  
 #  Check the link between tobacco and the AMR 
  
  df_model <- data.frame(
  y = datAMR[, AMR],
  smoking_status = smoking_status,
  covar  
)
  mod_tob <- lm(y ~ ., data = df_model)
     tob_sign =  summary(mod_tob)$coefficients[2,4]  < pval_thres 
   
    #  check the link between the AMR and survival
     
     df_model <- data.frame(
  y = datAMR[, AMR],
  time = tcga_data$time,
  status = tcga_data$status,
  covar)
     
     mod_AMR <- survival::coxph(
  survival::Surv(time, status) ~ y +  ., 
  data = df_model  
)

   AMR_sign =  summary(mod_AMR)$coefficients[1, "Pr(>|z|)"] < pval_thres 
   
   # Step 2: Conditional independence testing
 
   if (tob_sign == TRUE & AMR_sign == TRUE) {
  
    print(paste0(" AMR:", AMR, " and Immune:", imm, " is kept for doanwstream analysis. "))
   # (Model 1) Which node coefficient will lose its significance between AMR and imm ?
     
     df_model <- data.frame(
  time = tcga_data$time,
  status = tcga_data$status,
  imm = datIMM[[imm]],
  amr = datAMR[[AMR]],
   covar
)
     mod_part <- survival::coxph(
  survival::Surv(time, status) ~ imm + amr +  .,
  data = df_model
)
    part_surv_sign = summary(mod_part)$coefficients[1:2, "Pr(>|z|)"] 

   
    # (Model 2) check the link between the immune and smoking status when controlling for AMR
    
    
     df_model <- data.frame(
   smoking_status = as.numeric(as.factor(labels)) -1,
             AMR = datAMR[,AMR],
      imm = datIMM[ ,imm],
   covar
)
    mod = glm(smoking_status~ ., data = df_model, family = binomial(link = "logit"))
    summary(mod)
    part_imm_sign = summary(mod)$coefficients[2:3,4] # check if imm is significant
    
    num_res[[pair]] = c( part_surv_sign,
                        part_imm_sign)
    names(num_res[[pair]]) = c("part_IMM_sign_to_surv", 
                               "part_AMR_sign_to_surv_when_IMM_controlled",
                               "part_AMR_sign_to_smoking",
                               "part_IMM_sign_to_smoking_when_AMR_controlled")
   } else {
     print(paste0(" AMR:", AMR, " and Immune:", imm, " is not kept for doanwstream analysis. "))
     #num_res[[pair]] = c(NA, NA, NA, NA)
     #names(num_res[[pair]]) = c("part_IMM_sign_to_surv", 
    #                            "part_AMR_sign_to_surv_when_IMM_controlled",
     #                           "part_AMR_sign_to_smoking",
     #                           "part_IMM_sign_to_smoking_when_AMR_controlled")
   }

  }


}
num_res = do.call(rbind, num_res)
num_res=data.frame(num_res)

# Directed acyclic graph 1
res_CAT1 = num_res[  num_res$part_IMM_sign_to_surv < pval_thres &
            num_res$part_AMR_sign_to_surv_when_IMM_controlled < pval_thres, ]
res_CAT1
rownames(res_CAT1)
saveRDS(rownames(res_CAT1), file = "~/projects/tims-pdac/real_data/results/05_DAG_validated_CAT1_withLF.rds")

# Directed acyclic graph 2
res_CAT2 = num_res[  num_res$part_IMM_sign_to_surv < pval_thres &
            num_res$part_AMR_sign_to_surv_when_IMM_controlled >= pval_thres, ]
rownames(res_CAT2)
saveRDS(rownames(res_CAT2), file = "~/projects/tims-pdac/real_data/results/05_DAG_validated_CAT2_withLF.rds")

```


```{r}
sessionInfo()
```


```{r, eval=TRUE}
knitr::knit_exit()
```

